
<!-- saved from url=(0049)http://people.mozilla.org/~sicking/webgl/ray.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ray tracer using WebGL</title>


<script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;

  const vec3 lightDir = vec3(0.577350269, 0.577350269, -0.577350269);
  varying vec3 vPosition;
  uniform vec3 cameraPos;

  //sphere center coordinates
  uniform vec3 sphere1Center;
  uniform vec3 sphere2Center;
  uniform vec3 sphere3Center;

  //cube center coordinates
  uniform vec3 cube1Center;

  bool intersectSphere(vec3 center, vec3 lStart, vec3 lDir, out float dist) {
    vec3 c = center - lStart;
    float b = dot(lDir, c);
    float d = b*b - dot(c, c) + 1.0;
    if (d < 0.0) {
      dist = 10000.0;
      return false;
    }

    dist = b - sqrt(d);
    if (dist < 0.0) {
      dist = 10000.0;
      return false;
    }

    return true;
  }

  bool intersectCube(vec3 center, vec3 lStart, vec3 lDir, out float dist) {
    vec3 c = center - lStart;
    float b = dot(lDir, c);
    float d = b*b - dot(c, c) + 1.0;
    if (d < 0.0) {
      dist = 10000.0;
      return false;
    }

    dist = b - sqrt(d);
    if (dist < 0.0) {
      dist = 10000.0;
      return false;
    }

    return true;
  }

vec3 lightAt(vec3 N, vec3 V, vec3 color, vec3 p) {
    /*
     * Calculate the color of the currrent point
     * 
     * @param N the normal vector from point *p*
     * @param V the negative vector of the *cameraDirection* variable.  It's the vector from point *p* back to the camera
     * @param color the color at point *p* as determined by **intersectWorld()**
     * @param p the point we are drawing at
     */
    vec3 L = lightDir;
    
    // reflect(I,N) is a GLSL function that calculates the reflection direction for an incident vector
    // I - 2.0 * dot(N, I) * N
    // https://www.opengl.org/sdk/docs/man/html/reflect.xhtml
    vec3 R = reflect(-L, N);

    // calculate the specular angle   
    float spec = max(dot(R,V), 0.0);

    // calculate the diffusion angle
    float diff = max(dot(L,N), 0.0);

    float c, d;
    bool h1, h2, h3, h4;
            
    // if either the specular or diffuse angles are greater than 0, then we need to determine more about the point
    if (spec > 0.0 || diff > 0.0) {
        // if there is any sphere between the point and the light source, we darken it because it falls into the shadow of that sphere
        // otherwise, there is a clear line of sight, and that point is going to reflect back some of the light.
        // the intensity of that light is dependent on the relationship between the camera, the light source and that point.
        // if the camera falls along the path of the light source, then the reflected specular light is going to be stronger than otherwise
        h1 = intersectSphere(sphere1Center, p, L, d);
        h2 = intersectSphere(sphere2Center, p, L, d);
        h3 = intersectSphere(sphere3Center, p, L, d);
        h4 = intersectCube(cube1Center, p, L, d);
        if (h1 || h2 || h3 || h4) {
            c = 0.3;
        }
        else {
            // the larger the specular angle, the greater the specular reflection
            // the larger the diffuse angle, the greater the diffusion color
            // decreasing the power variable in the *pow* function increases the size of the specular reflection
            // the constants here modify the intensity of the reflection
            c = 0.3 + 0.4 * pow(spec, 10.0) + 0.7 * diff;
        }
    }
    else {
        c = 0.3;
    }
    
    if (c > 1.0) {
        return mix(color, vec3(1.6, 1.6, 1.6), c - 1.0);
    }

    return c * color;
  }

  bool intersectWorld(vec3 lStart, vec3 lDir, out vec3 pos, out vec3 normal, out vec3 color) {
    /*
     * Checks to see if there is an object between the point on the plate and a point *lStart* with direction *lDir*
     * If there is, this function will change the color of that point appropriately based on the camera's relationship to the light source and what objects are in the way.
     *
     * @param lStart  the position of our viewpoint
     * @param lDir    the direction we are looking at from that viewpoint
     * @param pos     an empty vec3.  This function will set it. It is the point of intersection between *lStart* and the object along *lDir*
     * @param normal  an empty vec3.  This function will set it. It is the normal vector off the object's surface at point *pos* OR the normal to the floor
     * @param color   an empty vec3.  This function will set it. It is the color of the **current** point that we are rendering 
     *
     * @returns True if there is an object between lStart and the current point along lDir.  False otherwise
     */

    //distances between point and the *lStart*.
    float d1, d2, d3, d4;

    // boolean values to see if there is a sphere in between the point and *lStart*
    bool h1, h2, h3, h4;

    // check if sphere 1 is in the way
    h1 = intersectSphere(sphere1Center, lStart, lDir, d1);

    // check if sphere 2 is in the way
    h2 = intersectSphere(sphere2Center, lStart, lDir, d2);

    // check if sphere 3 is in the way
    h3 = intersectSphere(sphere3Center, lStart, lDir, d3);

    // check if cube 1 is in the way
    h4 = intersectCube(cube1Center, lStart, lDir, d4);
    /*
     * The next group of if statements determine:
     *    a) there is a object between the point and the light source
     *    b) which object is closest to the ground.
     * This allows us to color the floor with whichever object is closer
     */

    // sphere 1 is in the way and is the closest object to *lStart*
    // sphere 1 is colored BLUE
    if (h1 && d1 < d2 && d1 < d3 && d1 < d4) {

      //calculate the point where the line from *lStart* intersects the object
      pos = lStart + d1 * lDir;

      // the normal off of a vector is:
      //    the vector representing the point on the surface of the sphere / the vector representing the center of the sphere.
      // this calculates a line segment between the two points that points straight out of the sphere.
      normal = pos - sphere1Center;

      color = vec3(0.0, 0.0, 0.9);
    }
    // sphere 2 is in the way and is the closest object to *lStart*
    // sphere 2 is colored RED
    else if (h2 && d2 < d3 && d2 < d4) {
      pos = lStart + d2 * lDir;
      normal = pos - sphere2Center;
      color = vec3(0.9, 0.0, 0.0);
    }
    // if sphere 3 is in the way and is the closest object
    // sphere 3 is colored GREEN
    else if (h3 && d3 < d4) {
      pos = lStart + d3 * lDir;
      normal = pos - sphere3Center;
      color = vec3(0.0, 0.9, 0.0);
    }
    // if cube1 is in the way
    // cube1 is colored YELLOW
    else if(h4) {
      // the point on the cube where the intersection occurs
      pos = lStart + d4 * lDir;
      normal = pos - cube1Center;
      color = vec3(0.5, 0.5, 0.0);
    }
    // Otherwise, draw a black and white checkerboard pattern 
    else if (lDir.y < -0.01) {
      pos = lStart + ((lStart.y + 2.7) / -lDir.y) * lDir;
      // if the position is outside a certain range, then it is not a part of our scene.
      // Return FALSE to tell the main function to draw the background color at this point
      if (pos.x*pos.x + pos.z*pos.z > 30.0) {
        return false;
      }
      
      // the normal vector to the floor is always pointing directly upwards
      normal = vec3(0.0, 1.0, 0.0);
      
      // fract() is equivalent to x - floor(x)
      // if the fractional component of the x coordiante and z coordinate are both greater than 0.5, we draw a white point
      // otherwise, draw a black point
      if (fract(pos.x / 5.0) > 0.5 == fract(pos.z / 5.0) > 0.5) {
        color = vec3(1.0);
      }
      else {
        color = vec3(0.0);
      }
    }
    // if no intersect happens, then we return FALSE to tell the main function to draw a black point
    else {
     return false;
    }

    return true;
  }

  void main(void)
  {
    // vector between the current point and where the camera is positioned
    vec3 cameraDir = normalize(vPosition - cameraPos);

    vec3 p1, norm, p2;
    vec3 col, colT, colM, col3;

    // if there is a object between the current point and the the camera
    if (intersectWorld(cameraPos, cameraDir, p1, norm, colT)) {
      
      //calculate the light at the current point based on:
      //  norm: the 
      //  cameraDir: the direction of the camera
      //  colT: 
      //  p1:  
      col = lightAt(norm, -cameraDir, colT,p1);
      
      colM = (colT + vec3(0.7)) / 1.7;
      cameraDir = reflect(cameraDir, norm);

      if (intersectWorld(p1, cameraDir, p2, norm, colT)) {
        col += lightAt(norm, -cameraDir, colT,p2) * colM;

        colM *= (colT + vec3(0.7)) / 1.7;
 
        cameraDir = reflect(cameraDir, norm);

        if (intersectWorld(p2, cameraDir, p1, norm, colT)) {
          col += lightAt(norm, -cameraDir, colT,p1) * colM;
        }
      }
      gl_FragColor = vec4(col, 1.0);
    }
    else {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
</script>


<!-- The vertex shader for managing the vertices of the shapes in the scene -->
<script id="shader-vs" type="x-shader/x-vertex">
  /*
   * Vertex shader
   *
   * Each vertex has 3 variables
   *    aVertexPosition:  the x,y coordinates for the vertex
   *    aPlotPosition:    an attribute for the position of the 
   *
   * NOTE:  Everything is being drawn on the same Z-axis coordinate, so we don't have to worry about it later in our code.
   */

  attribute vec2 aVertexPosition;
  attribute vec3 aPlotPosition;

  varying vec3 vPosition;

  void main(void)
  {
    // tell WebGL where to draw the point
    // always drawn relative to z = 1.0
    gl_Position = vec4(aVertexPosition, 1.0, 1.0);
    vPosition = aPlotPosition;
 }
</script>



<!-- Main Javascript function to load and launch the WebGL components and activate the scene -->
<script type="application/x-javascript">

  var gl;
  function initGL(canvas) {
    try {
      gl = canvas.getContext("experimental-webgl");
      gl.viewport(0, 0, canvas.width, canvas.height);
    } catch(e) {
    }
    if (!gl) {
      alert("Could not initialise WebGL, sorry :-(");
    }
  }

  function getShader(gl, id)
  {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var shader;
      if (shaderScript.type == "x-shader/x-fragment")
      {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      }
      else if (shaderScript.type == "x-shader/x-vertex")
      {
          shader = gl.createShader(gl.VERTEX_SHADER);
      }
      else
      {
          return null;
      }

      gl.shaderSource(shader, shaderScript.textContent);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
      {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }

      return shader;
  }

  var shaderProgram;
  var aVertexPosition;
  function initShaders()
  {
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
    {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(aVertexPosition);

    aPlotPosition = gl.getAttribLocation(shaderProgram, "aPlotPosition");
    gl.enableVertexAttribArray(aPlotPosition);

    cameraPos = gl.getUniformLocation(shaderProgram, "cameraPos");
    sphere1Center = gl.getUniformLocation(shaderProgram, "sphere1Center");
    sphere2Center = gl.getUniformLocation(shaderProgram, "sphere2Center");
    sphere3Center = gl.getUniformLocation(shaderProgram, "sphere3Center");
    cube1Center = gl.getUniformLocation(shaderProgram,"cube1Center");

  }


  function initBuffers()
  {
    vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    var vertices = [
         1.0,  1.0,
        -1.0,  1.0,
         1.0, -1.0,
        -1.0, -1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);


    var plotPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, plotPositionBuffer);
    gl.vertexAttribPointer(aPlotPosition, 3, gl.FLOAT, false, 0, 0);
  }

  function crossProd(v1, v2) {
    return { x: v1.y*v2.z - v2.y*v1.z,
             y: v1.z*v2.x - v2.z*v1.x,
             z: v1.x*v2.y - v2.x*v1.y };
  }

  function normalize(v) {
    l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
    return { x: v.x/l, y: v.y/l, z: v.z/l };
  }

  function vectAdd(v1, v2) {
    return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
  }

  function vectSub(v1, v2) {
    return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
  }

  function vectMul(v, l) {
    return { x: v.x*l, y: v.y*l, z: v.z*l };
  }

  function pushVec(v, arr) {
    arr.push(v.x, v.y, v.z);
  }

  t = 0;
  function drawScene()
  {

    /*
     * The sphere's rotate around the world based on the time since the application started.
     * The camera also moves around the world to show the scene from different angles.
     */
    /*sphere 1 coordinates*/
    x1 = Math.sin(t * 1.1) * 1.5;
    y1 = Math.cos(t * 1.3) * 1.5;
    z1 = Math.sin(t + Math.PI/3) * 1.5;
    
    /*sphere 2 coordinates*/
    x2 = Math.cos(t * 1.2) * 1.5;
    y2 = Math.sin(t * 1.4) * 1.5;
    z2 = Math.sin(t*1.25 - Math.PI/3) * 1.5;
    

    /*sphere 3 coordinates*/
    x3 = Math.cos(t * 1.15) * 1.5;
    y3 = Math.sin(t * 1.37) * 1.5;
    z3 = Math.sin(t*1.27) * 1.5;

    /*cube 1 coordinates*/
    x4 = Math.cos(t * 1.2) * 1.5;
    y4 = Math.cos(t * 1.3) * 1.5;
    z4 = Math.sin(t*1.27) * 1.5;


    /*rotate the camera in a sinsoudial fashion around the scene*/
    cameraFrom = { x: Math.sin(t * 0.4) * 18,
                   y: Math.sin(t * 0.13) * 5 + 5,
                   z: Math.cos(t * 0.4) * 18 };

    cameraTo = { x:0, y:0, z:0 };

    // set our field of view.  The larger the value, the lower our field of view.  The smaller the value, the larger the field.
    // by increasing the field, the objects in the scene will appear smaller.
    cameraPersp = 4;

    // logic to move the camera around and set our viewpoint
    up = { x: 0, y: 1, z: 0 };
    cameraDir = normalize(vectSub(cameraTo, cameraFrom));

    cameraLeft = normalize(crossProd(cameraDir, up));
    cameraUp = normalize(crossProd(cameraLeft, cameraDir));
    // cameraFrom + cameraDir * cameraPersp
    cameraCenter = vectAdd(cameraFrom, vectMul(cameraDir, cameraPersp));
    // cameraCenter + cameraUp + cameraLeft * ratio
    cameraTopLeft  = vectAdd(vectAdd(cameraCenter, cameraUp),
                             vectMul(cameraLeft, ratio));
    cameraBotLeft  = vectAdd(vectSub(cameraCenter, cameraUp),
                             vectMul(cameraLeft, ratio));
    cameraTopRight = vectSub(vectAdd(cameraCenter, cameraUp),
                             vectMul(cameraLeft, ratio));
    cameraBotRight = vectSub(vectSub(cameraCenter, cameraUp),
                             vectMul(cameraLeft, ratio));


    //corners = [1.2, 1, -1.2, -1.2, 1, -12, 1.2, -1, -1.2, -1.2, -1, -1.2];
    corners = [];
    pushVec(cameraTopRight, corners);
    pushVec(cameraTopLeft, corners);
    pushVec(cameraBotRight, corners);
    pushVec(cameraBotLeft, corners);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(corners), gl.STATIC_DRAW);

    gl.uniform3f(cameraPos, cameraFrom.x, cameraFrom.y, cameraFrom.z);
    gl.uniform3f(sphere1Center, x1, y1, z1);
    gl.uniform3f(sphere2Center, x2, y2, z2);
    gl.uniform3f(sphere3Center, x3, y3, z3);
    gl.uniform3f(cube1Center, x4, y4, z4);



    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // increment the "time" variable to rotate the camera and objects in the scene
    t += 0.03;
    if (t > Math.PI * 200) {
      t -= Math.PI * 200;
    }
  }

  var timer = 0;

  var canvas;
  function webGLStart()
  {
    canvas = document.getElementById("canvas");
    initGL(canvas);
    initShaders()

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    gl.clearDepth(1.0);

    initBuffers();
  }

  function flipAnim()
  {
    if (timer) {
      clearInterval(timer);
      timer = 0;
    }
    else {
      timer = setInterval(drawScene, 15);
    }
  }

  var ratio;
  function resizeCanvas(w)
  {
    if (w == -1) {
      document.getElementById('contrib').style.display = "none";
      canvas.style.display = "none";
      canvas.parentNode.style.position = "absolute";
      canvas.parentNode.style.top = 0;
      w = canvas.parentNode.parentNode.offsetWidth;
      ratio = w / canvas.parentNode.parentNode.offsetHeight;
      canvas.style.display = "";
    }
    else {
      document.getElementById('contrib').style.display = "";
      ratio = 1.6;
      canvas.parentNode.style.position = "";
      canvas.parentNode.style.top = "";
      window.onresize = null;
    }
    canvas.width = w;
    canvas.height = w / ratio;

    gl.viewport(0, 0, canvas.width, canvas.height);

    t -= 0.03;
    drawScene();
  }

  var resizeTimer = false;
  function fullScreen() {
    window.onresize = function() {
      if (resizeTimer) {
        clearTimeout(resizeTimer);
      }
      resizeTimer = setTimeout(function() {
        fullScreen();
      }, 100);
    };
    
    resizeCanvas(-1);
  }

</script>
</head>


<body onload="webGLStart(); resizeCanvas(600); flipAnim()" style="height: 100%; margin: 0">
  <div style="height:100%; margin: 0;">
    <div style="text-align:center; padding: 1em;">
      <input type="button" onclick="resizeCanvas(400)" value="small">
      <input type="button" onclick="resizeCanvas(600)" value="medium">
      <input type="button" onclick="resizeCanvas(800)" value="large">
      <input type="button" onclick="fullScreen();" value="very large">
      &nbsp;&nbsp;&nbsp;&nbsp;
      <input type="button" onclick="flipAnim()" value="pause">
    </div>
    <div style="z-index:-1; text-align:center; width:100%;">
      <canvas id="canvas" style="border: none;" width="600" height="375"></canvas>
    </div>
  </div>
  <div style="margin: -8em 1em 0;" id="contrib">
  </div>



</body></html>